#!/usr/bin/python
# -*- coding:UTF-8 -*-

################################################################################
#
# Copyright 2010 Carlos Ramisch
#
# join_web_cache.py is part of mwetoolkit
#
# mwetoolkit is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# mwetoolkit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mwetoolkit.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
"""
    This script joins two web frequency cache files. These files are generated
    by counter.py and store the Google or Yahoo word and ngram counts. If two
    cache entries have the same value, the newest one is kept. Joining cache
    files from Yahoo and from Google in a single file is not recommended since
    these two search engines have different index sizes and counts.
    
    For more information, call the script with no parameter and read the
    usage instructions.
"""

import sys
import getopt
import cPickle

from util import read_options, treat_options_simplest, usage, verbose, \
                 set_verbose
#from classes.__common import TEMP_PREFIX, TEMP_FOLDER
     
################################################################################     
# GLOBALS     
     
usage_string = """Usage: 
    
python %(program)s [OPTIONS] <cache1.dat> <cache2.dat> <cache_out.dat>

OPTIONS may be:

-v OR --verbose
    Print messages that explain what is happening.

    The <cache*.dat> files must be generated by counter.py, and should be
    different from each other.
"""       

################################################################################

def combine_caches( cache1, cache2, cache_out ) :
    """
    """    
    # First, copy all entries from cache1 to cache_out
    for k1 in cache1.keys() :
        cache_out[ k1 ] = cache1[ k1 ]   
    # Update entries in cache_out if corresponding entry in cache_2 is newer
    for k2 in cache2.keys() :        
        ( freq2, date2 ) = cache2[ k2 ]
        ( freq_out, date_out ) = cache_out.get( k2, ( -1, None ) )
        if date_out is None :
            cache_out[ k2 ] = ( freq2, date2 )
        elif date2 < date_out :
            cache_out[ k2 ] = ( freq2, date2 )

################################################################################     
# MAIN SCRIPT

longopts = [ "verbose=" ]
arg = read_options( "v:", longopts, treat_options_simplest, 3, usage_string )

try :    
    verbose( "Opening files and checking consistency" )
    cache1_desc = open( arg[ 0 ], "r" )
    cache2_desc = open( arg[ 1 ], "r" )
    cache_out_desc = open( arg[ 2 ], "w" )
    cache1 = cPickle.load( cache1_desc )
    cache2 = cPickle.load( cache2_desc )
    cache_out = {}
    verbose( "Combining cache files..." )
    combine_caches( cache1, cache2, cache_out )
    verbose( "Writing new cache file..." )
    cPickle.dump( cache_out, cache_out_desc )
except IOError, err :
    print >> sys.stderr, err
except Exception, err :
    print >> sys.stderr, err
    print >> sys.stderr, "You probably provided an invalid cache file," + \
                         " please use only counter.py formatted files."
